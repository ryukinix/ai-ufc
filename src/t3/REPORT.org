#+OPTIONS: toc:nil todo:nil
#+TITLE: Inteligência Computacional - T3@@latex:\\@@ Redes Neurais e Algorítimos Genéticos
#+LANGUAGE: bt-br
#+LATEX_HEADER: \usepackage[]{babel}
#+AUTHOR: Manoel Vilela

#+BEGIN_ABSTRACT

Este relatório descreve soluções de problemas na área de Redes Neurais
RBF e ELM, algorítmos genéticos. Este trabalho é a terceira avaliação
prática da disciplina Inteligência Computacional na UFC do Campus de
Sobral ministrada pelo professor Jarbas.

#+END_ABSTRACT


* Introdução

A linguagem utilizada foi Python, testado com o compilador cPython
versão 3.6 e 3.7, na qual pode ser encontrado no /site/
[[https://www.python.org][www.python.org]]. A execução dos programas é direta. Cada questão é
enumerada por ~q<n>.py~, na qual é possível executá-la por exemplo
como ~python q1.py~.

Talvez seja necessário instalar em seu ambiente algumas dependências
externas com a ferramenta ~pip~. Ao abrir um terminal no diretório
local da execução, assegure-se de executar:

~pip install -r requirements.txt~


* DONE Q1
  CLOSED: [2019-06-21 Fri 21:06]

Nessa questão a solução baseia-se no fundamento que a curva separadora
de classe fica na fronteira numérica entre os extremos. Por exemplo,
dado que as classes nesse problema são ~-1~ e ~1~ a fronteira da curva
deverá ser ~0~.

Partindo desse princípio, calcula-se os mínimos e máximos das features
~x1~ e ~x2~ do conjunto de dados ~twomoons.dat~ fornecido. A partir de
tais valores, após o treinamento da rede neural ELM é criado um espaço
linear de 200 pontos do produto cartesiano entre ~(x1, x2)~, dessa
maneira gerando uma nova matriz de ~características~ a ser
classificada.

Ao classificar tal matriz, estima-se com uma tolerância fixa que os
resultados não-truncados da rede tal que \( |y| < 0.05 \) pertença a
curva separadora. A seguir é ilustrado um gráfico com todos os pontos
gerados nesse espaço, colorizado por classe e a curva que os separam
baseado na rede ELM.



#+CAPTION: Curva Separada da Rede Neural ELM em preto. ~Vermelho=1~, ~Azul=-1~.
[[file:pics/fit-curve.png]]


* TODO Q2


* DONE Q3
  CLOSED: [2019-06-21 Fri 21:06]

Questão embora simples, bastante interessante para exercitar os
conceitos de algorítmos genéticos. O fluxo geral de execução segue:

1. Criação de uma população inicial pseudo-aleatória de 100 indíviduos;
2. Avaliação da população sobre a função-objetiva;
3. Seleção de indíviduos por uma roleta viciada parametrizada pela
   aptidão;
4. Cruzamento dos indíviduos com algoritmo de corte de um ponto;
5. Mutação com taxa probabilística de 0.5%;
6. Defina esta população como a nova geração;
7. Verifique se a condição de parada foi alcançada;
8. Pule para o passo 2.

Como exemplo, a seguir está a saída do programa para as configurações padrões.

#+BEGIN_EXAMPLE
---- G E N E T I C  --  A L G O R I T H M S ----
O indíviduo possui 20 bits tal que 10 bits é reservado para x e 10
bits para y.  A função objetiva f deve ser maximizada tal que a tupla
(x, y) pertença a subfaixa [0, 20] no conjunto R².

f(x, y) = |x * sin(y * (pi/4)) + y * sin(x * (pi/4))|

--- P A R A M E T E R S ---
N_BITS:  20
POPULATION_SIZE:  100
SELECTION: ROLETA
CROSSOVER: 1-cut point
MUTATION PROBABILITY:  0.005
VERBOSE:  False
------ B E S T -- S O L U T I O N ------
(x, y) = (18.0841, 18.1036)
f(x,y) = 36.0884
Best generation = 27
#+END_EXAMPLE


Caso queira-se ver detalhes de média, desvio-padrão e outras métricas
por geração, execute o programa com ~VERBOSE=True~. Opcionalmente
pode-se executar como:

#+BEGIN_EXAMPLE
python q3.py --verbose
#+END_EXAMPLE
